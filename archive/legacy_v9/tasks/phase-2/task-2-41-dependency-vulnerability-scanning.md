# Task 2-41: Dependency Vulnerability Scanning

**Phase:** 2 - Performance & Production Readiness  
**Week:** 7 - Production Infrastructure  
**Priority:** HIGH  
**Estimated Hours:** 3 hours

---

## ğŸ“‹ OVERVIEW

Implement automated dependency vulnerability scanning using Safety, Snyk, or similar tools to identify and remediate security vulnerabilities in Python packages.

---

## ğŸ¯ OBJECTIVES

1. Set up vulnerability scanning tools
2. Configure automated scanning
3. Integrate with CI/CD pipeline
4. Create vulnerability reports
5. Implement remediation workflow
6. Document security procedures

---

## ğŸ“Š CURRENT STATE

**Existing:**
- Python dependencies in requirements.txt
- No vulnerability scanning
- No security monitoring

**Gaps:**
- No vulnerability detection
- No automated scanning
- No security alerts
- Risk of vulnerable dependencies

---

## ğŸ”§ IMPLEMENTATION

### 1. Safety Configuration

Create `scripts/security/scan-dependencies.sh`:

```bash
#!/bin/bash
#
# Dependency Vulnerability Scanner
#
# Scans Python dependencies for known vulnerabilities

set -e

echo "ğŸ” Scanning dependencies for vulnerabilities..."

# Install safety if not present
pip install --quiet safety

# Run safety check
echo ""
echo "Running Safety scan..."
safety check \
    --json \
    --output safety-report.json \
    || true

# Parse results
if [ -f "safety-report.json" ]; then
    VULN_COUNT=$(python3 -c "
import json
with open('safety-report.json') as f:
    data = json.load(f)
    print(len(data.get('vulnerabilities', [])))
")
    
    echo ""
    echo "ğŸ“Š Scan Results:"
    echo "  Vulnerabilities found: ${VULN_COUNT}"
    
    if [ "$VULN_COUNT" -gt "0" ]; then
        echo ""
        echo "âš ï¸  VULNERABILITIES DETECTED!"
        echo ""
        safety check --full-report
        exit 1
    else
        echo ""
        echo "âœ… No vulnerabilities found"
    fi
else
    echo "âŒ Safety scan failed"
    exit 1
fi
```

---

### 2. Snyk Integration

Create `.snyk`:

```yaml
# Snyk Configuration

# Language settings
language-settings:
  python: '3.11'

# Ignore specific vulnerabilities (with justification)
ignore:
  # Example: Ignore low-severity issue in dev dependency
  # 'SNYK-PYTHON-PACKAGE-12345':
  #   - '*':
  #       reason: 'Dev dependency only, not in production'
  #       expires: '2025-12-31'

# Patch settings
patch: {}
```

Create `scripts/security/snyk-scan.sh`:

```bash
#!/bin/bash
#
# Snyk Vulnerability Scanner
#
# Requires SNYK_TOKEN environment variable

set -e

if [ -z "$SNYK_TOKEN" ]; then
    echo "âš ï¸  SNYK_TOKEN not set, skipping Snyk scan"
    exit 0
fi

echo "ğŸ” Running Snyk vulnerability scan..."

# Install Snyk CLI
npm install -g snyk

# Authenticate
snyk auth $SNYK_TOKEN

# Test for vulnerabilities
snyk test \
    --severity-threshold=high \
    --json \
    --json-file-output=snyk-report.json \
    || true

# Monitor project
snyk monitor \
    --project-name="DRYAD.AI Backend"

echo "âœ… Snyk scan complete"
```

---

### 3. GitHub Actions Workflow

Create `.github/workflows/security-scan.yml`:

```yaml
name: Security Scan

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
  schedule:
    # Run daily at 2 AM
    - cron: '0 2 * * *'

jobs:
  security-scan:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install safety
      
      - name: Run Safety scan
        run: |
          safety check --json --output safety-report.json || true
      
      - name: Upload Safety report
        uses: actions/upload-artifact@v3
        with:
          name: safety-report
          path: safety-report.json
      
      - name: Run Snyk scan
        uses: snyk/actions/python@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high
      
      - name: Check for vulnerabilities
        run: |
          python scripts/security/check-vulnerabilities.py
```

---

### 4. Vulnerability Report Parser

Create `scripts/security/check-vulnerabilities.py`:

```python
#!/usr/bin/env python3
"""
Vulnerability Report Parser

Parse and analyze vulnerability scan results.
"""
from __future__ import annotations

import json
import sys
from pathlib import Path
from typing import List, Dict


def parse_safety_report(report_file: str) -> List[Dict]:
    """
    Parse Safety vulnerability report.
    
    Args:
        report_file: Path to Safety JSON report
    
    Returns:
        List of vulnerabilities
    """
    if not Path(report_file).exists():
        return []
    
    with open(report_file) as f:
        data = json.load(f)
    
    vulnerabilities = []
    for vuln in data.get("vulnerabilities", []):
        vulnerabilities.append({
            "package": vuln.get("package_name"),
            "version": vuln.get("analyzed_version"),
            "vulnerability": vuln.get("vulnerability_id"),
            "severity": vuln.get("severity", "unknown"),
            "description": vuln.get("advisory"),
            "fixed_in": vuln.get("fixed_in", [])
        })
    
    return vulnerabilities


def generate_report(vulnerabilities: List[Dict]) -> str:
    """
    Generate vulnerability report.
    
    Args:
        vulnerabilities: List of vulnerabilities
    
    Returns:
        Report text
    """
    if not vulnerabilities:
        return "âœ… No vulnerabilities found"
    
    report = f"âš ï¸  Found {len(vulnerabilities)} vulnerabilities:\n\n"
    
    # Group by severity
    by_severity = {}
    for vuln in vulnerabilities:
        severity = vuln["severity"]
        if severity not in by_severity:
            by_severity[severity] = []
        by_severity[severity].append(vuln)
    
    # Report by severity
    for severity in ["critical", "high", "medium", "low"]:
        if severity not in by_severity:
            continue
        
        vulns = by_severity[severity]
        report += f"\n{severity.upper()} ({len(vulns)}):\n"
        
        for vuln in vulns:
            report += f"\n  ğŸ“¦ {vuln['package']} {vuln['version']}\n"
            report += f"     {vuln['vulnerability']}\n"
            report += f"     {vuln['description'][:100]}...\n"
            if vuln['fixed_in']:
                report += f"     Fix: Upgrade to {', '.join(vuln['fixed_in'])}\n"
    
    return report


def main():
    """Main function."""
    print("ğŸ” Analyzing vulnerability reports...\n")
    
    # Parse Safety report
    safety_vulns = parse_safety_report("safety-report.json")
    
    # Generate report
    report = generate_report(safety_vulns)
    print(report)
    
    # Exit with error if critical/high vulnerabilities found
    critical_high = [
        v for v in safety_vulns
        if v["severity"] in ["critical", "high"]
    ]
    
    if critical_high:
        print(f"\nâŒ Found {len(critical_high)} critical/high vulnerabilities")
        sys.exit(1)
    else:
        print("\nâœ… No critical/high vulnerabilities found")
        sys.exit(0)


if __name__ == "__main__":
    main()
```

---

### 5. Automated Remediation

Create `scripts/security/auto-update-deps.sh`:

```bash
#!/bin/bash
#
# Automated Dependency Updates
#
# Updates dependencies to fix vulnerabilities

set -e

echo "ğŸ”„ Checking for dependency updates..."

# Install pip-audit
pip install pip-audit

# Run audit
pip-audit --fix --dry-run > audit-report.txt

# Show report
cat audit-report.txt

# Ask for confirmation
read -p "Apply updates? (yes/no): " CONFIRM

if [ "$CONFIRM" = "yes" ]; then
    pip-audit --fix
    
    # Regenerate requirements
    pip freeze > requirements.txt
    
    echo "âœ… Dependencies updated"
    echo "âš ï¸  Please test the application and commit changes"
else
    echo "Updates cancelled"
fi
```

---

### 6. Security Dashboard

Create `app/api/v1/endpoints/security.py`:

```python
"""
Security Monitoring Endpoints

Expose security scan results.
"""
from __future__ import annotations

import json
from pathlib import Path
from fastapi import APIRouter
from pydantic import BaseModel

router = APIRouter()


class SecurityStatus(BaseModel):
    """Security status response."""
    status: str
    vulnerabilities_count: int
    last_scan: str | None = None


@router.get("/security/status", response_model=SecurityStatus)
async def get_security_status():
    """Get security scan status."""
    report_file = Path("safety-report.json")
    
    if not report_file.exists():
        return SecurityStatus(
            status="unknown",
            vulnerabilities_count=0,
            last_scan=None
        )
    
    with open(report_file) as f:
        data = json.load(f)
    
    vuln_count = len(data.get("vulnerabilities", []))
    
    return SecurityStatus(
        status="vulnerable" if vuln_count > 0 else "secure",
        vulnerabilities_count=vuln_count,
        last_scan=data.get("scan_time")
    )
```

---

## âœ… ACCEPTANCE CRITERIA

- [ ] Safety scanning configured
- [ ] Snyk integration set up
- [ ] CI/CD pipeline includes security scans
- [ ] Vulnerability reports generated
- [ ] Automated remediation available
- [ ] Security dashboard working
- [ ] Documentation complete

---

## ğŸ§ª TESTING

```bash
# Run Safety scan
./scripts/security/scan-dependencies.sh

# Run Snyk scan
./scripts/security/snyk-scan.sh

# Check vulnerabilities
python scripts/security/check-vulnerabilities.py

# Test auto-update
./scripts/security/auto-update-deps.sh
```

---

## ğŸ“ NOTES

- Run scans daily in CI/CD
- Review vulnerabilities promptly
- Update dependencies regularly
- Test after updates
- Document exceptions with justification


